{"ast":null,"code":"var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function (name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function (row, i) {\n    return f(object(row), i, columns);\n  };\n} // Compute unique columns in order of discovery.\n\n\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n  rows.forEach(function (row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n  return columns;\n}\n\nexport default function (delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert,\n        columns,\n        rows = parseRows(text, function (row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [],\n        // output rows\n    N = text.length,\n        I = 0,\n        // current character index\n    n = 0,\n        // current line number\n    t,\n        // current token\n    eof = N <= 0,\n        // current token followed by EOF?\n    eol = false; // current token followed by EOL?\n    // Strip the trailing newline.\n\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL; // Unescape quotes.\n\n      var i,\n          j = I,\n          c;\n\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) {\n          ;\n        }\n\n        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {\n          eol = true;\n          if (text.charCodeAt(I) === NEWLINE) ++I;\n        }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      } // Find next delimiter or newline.\n\n\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {\n          eol = true;\n          if (text.charCodeAt(I) === NEWLINE) ++I;\n        } else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      } // Return last token before EOF.\n\n\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n\n      while (t !== EOL && t !== EOF) {\n        row.push(t), t = token();\n      }\n\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {\n      return columns.map(function (column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\" : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}","map":{"version":3,"sources":["/Users/zameerbharwani/Desktop/react-d3-dashboard/node_modules/d3-dsv/src/dsv.js"],"names":["EOL","EOF","QUOTE","NEWLINE","RETURN","objectConverter","columns","Function","map","name","i","JSON","stringify","join","customConverter","f","object","row","inferColumns","rows","columnSet","Object","create","forEach","column","push","delimiter","reFormat","RegExp","DELIMITER","charCodeAt","parse","text","convert","parseRows","N","length","I","n","t","eof","eol","token","j","c","slice","replace","format","formatValue","concat","formatRows","formatRow","test"],"mappings":"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","sourcesContent":["var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}\n"]},"metadata":{},"sourceType":"module"}