{"ast":null,"code":"import { dispatch } from \"d3-dispatch\";\nimport { map } from \"d3-collection\";\nimport { timer } from \"d3-timer\";\nexport function x(d) {\n  return d.x;\n}\nexport function y(d) {\n  return d.y;\n}\nvar initialRadius = 10,\n    initialAngle = Math.PI * (3 - Math.sqrt(5));\nexport default function (_nodes) {\n  var simulation,\n      _alpha = 1,\n      _alphaMin = 0.001,\n      _alphaDecay = 1 - Math.pow(_alphaMin, 1 / 300),\n      _alphaTarget = 0,\n      _velocityDecay = 0.6,\n      forces = map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\");\n\n  if (_nodes == null) _nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n\n    if (_alpha < _alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick() {\n    var i,\n        n = _nodes.length,\n        node;\n    _alpha += (_alphaTarget - _alpha) * _alphaDecay;\n    forces.each(function (force) {\n      force(_alpha);\n    });\n\n    for (i = 0; i < n; ++i) {\n      node = _nodes[i];\n      if (node.fx == null) node.x += node.vx *= _velocityDecay;else node.x = node.fx, node.vx = 0;\n      if (node.fy == null) node.y += node.vy *= _velocityDecay;else node.y = node.fy, node.vy = 0;\n    }\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = _nodes.length, node; i < n; ++i) {\n      node = _nodes[i], node.index = i;\n\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(i),\n            angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(_nodes);\n    return force;\n  }\n\n  initializeNodes();\n  return simulation = {\n    tick: tick,\n    restart: function restart() {\n      return stepper.restart(step), simulation;\n    },\n    stop: function stop() {\n      return stepper.stop(), simulation;\n    },\n    nodes: function nodes(_) {\n      return arguments.length ? (_nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : _nodes;\n    },\n    alpha: function alpha(_) {\n      return arguments.length ? (_alpha = +_, simulation) : _alpha;\n    },\n    alphaMin: function alphaMin(_) {\n      return arguments.length ? (_alphaMin = +_, simulation) : _alphaMin;\n    },\n    alphaDecay: function alphaDecay(_) {\n      return arguments.length ? (_alphaDecay = +_, simulation) : +_alphaDecay;\n    },\n    alphaTarget: function alphaTarget(_) {\n      return arguments.length ? (_alphaTarget = +_, simulation) : _alphaTarget;\n    },\n    velocityDecay: function velocityDecay(_) {\n      return arguments.length ? (_velocityDecay = 1 - _, simulation) : 1 - _velocityDecay;\n    },\n    force: function force(name, _) {\n      return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);\n    },\n    find: function find(x, y, radius) {\n      var i = 0,\n          n = _nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n      if (radius == null) radius = Infinity;else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = _nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n    on: function on(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/zameerbharwani/Desktop/react-d3-dashboard/node_modules/d3-force/src/simulation.js"],"names":["dispatch","map","timer","x","d","y","initialRadius","initialAngle","Math","PI","sqrt","nodes","simulation","alpha","alphaMin","alphaDecay","pow","alphaTarget","velocityDecay","forces","stepper","step","event","tick","call","stop","i","n","length","node","each","force","fx","vx","fy","vy","initializeNodes","index","isNaN","radius","angle","cos","sin","initializeForce","initialize","restart","_","arguments","name","remove","set","get","find","dx","dy","d2","closest","Infinity","on"],"mappings":"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","sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {map} from \"d3-collection\";\nimport {timer} from \"d3-timer\";\n\nexport function x(d) {\n  return d.x;\n}\n\nexport function y(d) {\n  return d.y;\n}\n\nvar initialRadius = 10,\n    initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nexport default function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\");\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick() {\n    var i, n = nodes.length, node;\n\n    alpha += (alphaTarget - alpha) * alphaDecay;\n\n    forces.each(function(force) {\n      force(alpha);\n    });\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (node.fx == null) node.x += node.vx *= velocityDecay;\n      else node.x = node.fx, node.vx = 0;\n      if (node.fy == null) node.y += node.vy *= velocityDecay;\n      else node.y = node.fy, node.vy = 0;\n    }\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}